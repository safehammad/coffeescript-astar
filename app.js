// Generated by CoffeeScript 1.3.3
(function() {
  var CLIENT_WIDTH, Circle, DEFAULT_MAZE, MAZE_WIDTH, Maze, SCALE, paper, solveMaze,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  paper = Raphael("maze", "768", "75%");

  CLIENT_WIDTH = paper.canvas.clientWidth;

  MAZE_WIDTH = 19;

  SCALE = CLIENT_WIDTH / MAZE_WIDTH;

  DEFAULT_MAZE = '*******************\n*        *        *\n*        *  **    *\n*        *  *F    *\n*    *** *  *******\n*    * @ *        *\n*    ********     *\n*    *     *      *\n*  * *  *  *      *\n*  ***  *  ****   *\n*       *     *   *\n*       *         *\n*******************';

  Circle = (function() {
    var COLOURS, RADIUS;

    COLOURS = {
      '*': '#900',
      '@': '#ff0',
      'F': '#00f',
      'S': '#ffa500',
      '#': '#990'
    };

    RADIUS = CLIENT_WIDTH / MAZE_WIDTH / 2 - 2;

    function Circle(row, col, type) {
      var x, y, _ref;
      _ref = this.coords(row, col), x = _ref[0], y = _ref[1];
      this.circle = paper.circle(x, y, RADIUS).attr({
        "fill": COLOURS[type],
        "stroke": "#aaa",
        "stroke-width": "2"
      });
    }

    Circle.prototype.move = function(row, col) {
      var x, y, _ref,
        _this = this;
      this.circle.toFront();
      this.circle.animate({
        r: RADIUS * 2,
        opacity: .25
      }, 100, "<>", function() {
        return _this.circle.animate({
          r: RADIUS,
          opacity: 1
        }, 250, "<>");
      });
      _ref = this.coords(row, col), x = _ref[0], y = _ref[1];
      return this.circle.attr("cx", x).attr("cy", y);
    };

    Circle.prototype.coords = function(row, col) {
      return [col * SCALE + SCALE / 2, row * SCALE + SCALE / 2];
    };

    return Circle;

  })();

  Maze = (function() {

    function Maze(maze) {
      var col, row, _ref;
      this.maze = maze;
      this.next = __bind(this.next, this);

      this.previous = __bind(this.previous, this);

      this.changeStart = __bind(this.changeStart, this);

      this.initRoute = __bind(this.initRoute, this);

      this.route = solveMaze(maze);
      this.trails = [];
      _ref = this.route[0], row = _ref[0], col = _ref[1];
      this.bot = new Circle(row, col, "@");
      this.initMaze();
      this.initRoute();
    }

    Maze.prototype.initMaze = function() {
      var col, colnum, row, rownum, rows, _i, _len, _results;
      rows = this.maze.split('\n');
      _results = [];
      for (rownum = _i = 0, _len = rows.length; _i < _len; rownum = ++_i) {
        row = rows[rownum];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (colnum = _j = 0, _len1 = row.length; _j < _len1; colnum = ++_j) {
            col = row[colnum];
            if (col !== ' ' && col !== '@') {
              _results1.push(new Circle(rownum, colnum, col));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };

    Maze.prototype.initRoute = function() {
      var col, node, row, _i, _len, _ref, _ref1;
      _ref = this.trails;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        node.circle.remove();
      }
      this.trails.length = 0;
      this.routeIndex = 0;
      _ref1 = this.route[0], row = _ref1[0], col = _ref1[1];
      this.bot.move(row, col);
      return this.trails.push(new Circle(row, col, "S"));
    };

    Maze.prototype.changeStart = function(event) {
      var col, maze, row, rows, _ref;
      _ref = this.toMazeCoords(event.x, event.y), row = _ref[0], col = _ref[1];
      maze = this.maze.replace("@", " ");
      rows = maze.split('\n');
      rows[row] = rows[row].slice(0, col) + '@' + rows[row].slice(col + 1);
      maze = rows.join('\n');
      this.route = solveMaze(maze);
      return this.initRoute();
    };

    Maze.prototype.updateIndex = function(step) {
      this.routeIndex += step;
      if (this.routeIndex < 0) {
        this.routeIndex = 0;
        return false;
      }
      if (this.routeIndex > this.route.length - 1) {
        this.routeIndex = this.route.length - 1;
        return false;
      }
      return true;
    };

    Maze.prototype.previous = function() {
      var col, row, _ref;
      if (!this.updateIndex(-1)) {
        return;
      }
      _ref = this.route[this.routeIndex], row = _ref[0], col = _ref[1];
      this.trails.pop().circle.remove();
      return this.bot.move(row, col);
    };

    Maze.prototype.next = function() {
      var col, row, _ref;
      if (!this.updateIndex(1)) {
        return;
      }
      _ref = this.route[this.routeIndex], row = _ref[0], col = _ref[1];
      this.trails.push(new Circle(row, col, "#"));
      return this.bot.move(row, col);
    };

    Maze.prototype.toMazeCoords = function(x, y) {
      x -= paper.canvas.offsetLeft;
      y -= paper.canvas.offsetTop;
      return [Math.round((y - SCALE / 2) / SCALE), Math.round((x - SCALE / 2) / SCALE)];
    };

    return Maze;

  })();

  solveMaze = function(maze) {
    var solver;
    solver = new this.astar.MazeSolver(maze);
    return solver.solve();
  };

  $(function() {
    var m;
    m = new Maze(DEFAULT_MAZE);
    $("#next").on("click", m.next);
    $("#previous").on("click", m.previous);
    $("#restart").on("click", m.initRoute);
    return paper.canvas.onclick = m.changeStart;
  });

}).call(this);
