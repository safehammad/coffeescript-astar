// Generated by CoffeeScript 1.5.0
(function() {
  var MazeSolver, Node, NodeSet,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Node = (function() {

    function Node(location, parent, g, end) {
      this.location = location;
      this.parent = parent;
      this.g = g;
      this.h = Math.abs(end[0] - location[0]) + Math.abs(end[1] - location[1]);
      this.f = this.g + this.h;
    }

    return Node;

  })();

  NodeSet = (function() {

    function NodeSet() {
      this.nodes = [];
    }

    NodeSet.prototype.add = function(node) {
      return this.nodes.push(node);
    };

    NodeSet.prototype.removeFirst = function() {
      return this.nodes.shift();
    };

    NodeSet.prototype.remove = function(node) {
      var index;
      index = this.nodes.indexOf(node);
      if (index !== -1) {
        return this.nodes.splice(index, 1);
      }
    };

    NodeSet.prototype.find = function(location) {
      var node, _i, _len, _ref;
      _ref = this.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        if (node.location[0] === location[0] && node.location[1] === location[1]) {
          return node;
        }
      }
      return null;
    };

    NodeSet.prototype.sort = function() {
      return this.nodes.sort(function(node1, node2) {
        return node1.f - node2.f;
      });
    };

    return NodeSet;

  })();

  MazeSolver = (function() {
    var DIRECTIONS;

    DIRECTIONS = [[-1, 0], [1, 0], [0, 1], [0, -1]];

    function MazeSolver(maze) {
      this.maze = maze;
      this.rows = this.maze.split('\n');
      this.end = this.location('F');
    }

    MazeSolver.prototype.solve = function() {
      var child, closedSet, col, current, existingNode, openSet, row, start, _i, _len, _ref;
      start = this.location('@');
      closedSet = new NodeSet;
      openSet = new NodeSet;
      current = new Node(start, null, 0, this.end);
      while (current.location[0] !== this.end[0] || current.location[1] !== this.end[1]) {
        for (_i = 0, _len = DIRECTIONS.length; _i < _len; _i++) {
          _ref = DIRECTIONS[_i], row = _ref[0], col = _ref[1];
          child = new Node([current.location[0] + row, current.location[1] + col], current, current.g + 1, this.end);
          if (this.content(child.location) === '*') {
            continue;
          }
          if (__indexOf.call(closedSet, child) < 0) {
            existingNode = openSet.find(child.location);
            if (existingNode) {
              if (existingNode.g > child.g) {
                openSet.remove(existingNode);
                openSet.add(child);
              }
            } else {
              openSet.add(child);
            }
          }
        }
        openSet.sort();
        current = openSet.removeFirst();
        closedSet.add(current);
      }
      return this.route(current);
    };

    MazeSolver.prototype.route = function(node, route) {
      if (route == null) {
        route = [];
      }
      route.unshift(node.location);
      if (node.parent) {
        return this.route(node.parent, route);
      } else {
        return route;
      }
    };

    MazeSolver.prototype.location = function(char) {
      var col, colnum, row, rownum, _i, _j, _len, _len1, _ref;
      _ref = this.rows;
      for (rownum = _i = 0, _len = _ref.length; _i < _len; rownum = ++_i) {
        row = _ref[rownum];
        for (colnum = _j = 0, _len1 = row.length; _j < _len1; colnum = ++_j) {
          col = row[colnum];
          if (col === char) {
            return [rownum, colnum];
          }
        }
      }
      return null;
    };

    MazeSolver.prototype.content = function(location) {
      return this.rows[location[0]][location[1]];
    };

    return MazeSolver;

  })();

  this.astar = {
    MazeSolver: MazeSolver
  };

}).call(this);
